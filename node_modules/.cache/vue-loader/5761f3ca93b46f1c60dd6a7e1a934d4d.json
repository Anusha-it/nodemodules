{"remainingRequest":"/Users/ksagar/vueproj/sample/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ksagar/vueproj/sample/src/views/Entities/Dataplanes.vue?vue&type=style&index=0&id=d03591b6&lang=scss&scoped=true&","dependencies":[{"path":"/Users/ksagar/vueproj/sample/src/views/Entities/Dataplanes.vue","mtime":1589260598000},{"path":"/Users/ksagar/vueproj/sample/node_modules/css-loader/index.js","mtime":499162500000},{"path":"/Users/ksagar/vueproj/sample/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/ksagar/vueproj/sample/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/ksagar/vueproj/sample/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/ksagar/vueproj/sample/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/ksagar/vueproj/sample/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.add-dp-button {\n  background-color: var(--logo-green) !important;\n}\n",{"version":3,"sources":["Dataplanes.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8dA;AACA;AACA","file":"Dataplanes.vue","sourceRoot":"src/views/Entities","sourcesContent":["<template>\n  <div class=\"dataplanes\">\n    <FrameSkeleton>\n      <DataOverview\n        :page-size=\"pageSize\"\n        :has-error=\"hasError\"\n        :is-loading=\"isLoading\"\n        :is-empty=\"isEmpty\"\n        :empty-state=\"empty_state\"\n        :display-data-table=\"true\"\n        :table-data=\"tableData\"\n        :table-data-is-empty=\"tableDataIsEmpty\"\n        table-data-function-text=\"View\"\n        table-data-row=\"name\"\n        @tableAction=\"tableAction\"\n        @reloadData=\"loadData\"\n      >\n        <template slot=\"additionalControls\">\n          <KButton\n            class=\"add-dp-button\"\n            appearance=\"primary\"\n            size=\"small\"\n            :to=\"dataplaneWizardRoute\"\n          >\n            Create Dataplane\n          </KButton>\n        </template>\n        <template slot=\"pagination\">\n          <Pagination\n            :has-previous=\"previous.length > 0\"\n            :has-next=\"hasNext\"\n            @next=\"goToNextPage\"\n            @previous=\"goToPreviousPage\"\n          />\n        </template>\n      </DataOverview>\n      <Tabs\n        :has-error=\"hasError\"\n        :is-loading=\"isLoading\"\n        :is-empty=\"isEmpty\"\n        :tabs=\"tabs\"\n        :tab-group-title=\"tabGroupTitle\"\n        initial-tab-override=\"overview\"\n      >\n        <template slot=\"overview\">\n          <LabelList\n            :has-error=\"entityHasError\"\n            :is-loading=\"entityIsLoading\"\n            :is-empty=\"entityIsEmpty\"\n            :items=\"entity\"\n          />\n        </template>\n        <template slot=\"yaml\">\n          <YamlView\n            :title=\"entityOverviewTitle\"\n            :has-error=\"entityHasError\"\n            :is-loading=\"entityIsLoading\"\n            :is-empty=\"entityIsEmpty\"\n            :content=\"rawEntity\"\n          />\n        </template>\n      </Tabs>\n    </FrameSkeleton>\n  </div>\n</template>\n\n<script>\nimport { mapGetters } from 'vuex'\nimport { getSome, humanReadableDate, getOffset } from '@/helpers'\nimport sortEntities from '@/mixins/EntitySorter'\nimport FrameSkeleton from '@/components/Skeletons/FrameSkeleton'\nimport Pagination from '@/components/Pagination'\nimport DataOverview from '@/components/Skeletons/DataOverview'\nimport Tabs from '@/components/Utils/Tabs'\nimport YamlView from '@/components/Skeletons/YamlView'\nimport LabelList from '@/components/Utils/LabelList'\n\nexport default {\n  name: 'Dataplanes',\n  metaInfo: {\n    title: 'Dataplanes'\n  },\n  components: {\n    FrameSkeleton,\n    Pagination,\n    DataOverview,\n    Tabs,\n    YamlView,\n    LabelList\n  },\n  mixins: [\n    sortEntities\n  ],\n  data () {\n    return {\n      isLoading: true,\n      isEmpty: false,\n      hasError: false,\n      entityIsLoading: true,\n      entityIsEmpty: false,\n      entityHasError: false,\n      tableDataIsEmpty: false,\n      empty_state: {\n        title: 'No Data',\n        message: 'There are no Dataplanes present.'\n      },\n      tableData: {\n        headers: [\n          { key: 'actions', hideLabel: true },\n          { label: 'Status', key: 'status' },\n          { label: 'Name', key: 'name' },\n          { label: 'Mesh', key: 'mesh' },\n          { label: 'Tags', key: 'tags' },\n          { label: 'Last Connected', key: 'lastConnected' },\n          { label: 'Last Updated', key: 'lastUpdated' },\n          { label: 'Total Updates', key: 'totalUpdates' }\n        ],\n        data: []\n      },\n      tabs: [\n        {\n          hash: '#overview',\n          title: 'Overview'\n        },\n        {\n          hash: '#yaml',\n          title: 'YAML'\n        }\n      ],\n      entity: null,\n      rawEntity: null,\n      firstEntity: null,\n      pageSize: this.$pageSize,\n      pageOffset: null,\n      next: null,\n      hasNext: false,\n      previous: []\n    }\n  },\n  computed: {\n    ...mapGetters({\n      environment: 'getEnvironment'\n    }),\n    tabGroupTitle () {\n      const entity = this.entity\n\n      if (entity) {\n        return `Dataplane: ${entity.name}`\n      } else {\n        return null\n      }\n    },\n    entityOverviewTitle () {\n      const entity = this.entity\n\n      if (entity) {\n        return `Entity Overview for ${entity.name}`\n      } else {\n        return null\n      }\n    },\n    dataplaneWizardRoute () {\n      // we change the route to the Dataplane\n      // wizard based on environment.\n      if (this.environment === 'universal') {\n        return { name: 'universal-dataplane' }\n      } else {\n        return { name: 'kubernetes-dataplane' }\n      }\n    }\n  },\n  watch: {\n    '$route' (to, from) {\n      this.loadData()\n    }\n  },\n  beforeMount () {\n    this.loadData()\n  },\n  methods: {\n    init () {\n      this.loadData()\n    },\n    goToPreviousPage () {\n      this.pageOffset = this.previous.pop()\n      this.next = null\n\n      this.loadData()\n    },\n    goToNextPage () {\n      this.previous.push(this.pageOffset)\n      this.pageOffset = this.next\n      this.next = null\n\n      this.loadData()\n    },\n    tableAction (ev) {\n      const data = ev\n\n      // reset back to the first tab\n      this.$store.dispatch('updateSelectedTab', this.tabs[0].hash)\n\n      // set the active table row\n      this.$store.dispatch('updateSelectedTableRow', data.name)\n\n      // load the data into the tabs\n      this.getEntity(data)\n    },\n    loadData () {\n      this.isLoading = true\n      this.isEmpty = false\n\n      const mesh = this.$route.params.mesh\n\n      const params = {\n        size: this.pageSize,\n        offset: this.pageOffset\n      }\n\n      const endpoint = (mesh === 'all')\n        ? this.$api.getAllDataplanes(params)\n        : this.$api.getAllDataplanesFromMesh(mesh)\n\n      const getDataplanes = () => {\n        return endpoint\n          .then(response => {\n            if (response.items.length > 0) {\n              // check to see if the `next` url is present\n              if (response.next) {\n                this.next = getOffset(response.next)\n                this.hasNext = true\n              } else {\n                this.hasNext = false\n              }\n\n              const items = this.sortEntities(response.items)\n              const final = []\n\n              // set the first item as the default for initial load\n              this.firstEntity = items[0].name\n\n              // load the YAML entity for the first item on page load\n              this.getEntity(items[0])\n\n              // set the selected table row for the first item on page load\n              this.$store.dispatch('updateSelectedTableRow', this.firstEntity)\n\n              items.forEach(item => {\n                this.$api.getDataplaneOverviewsFromMesh(item.mesh, item.name)\n                  .then(response => {\n                    const placeholder = 'n/a'\n\n                    let lastConnected\n                    let lastUpdated\n                    let tags = placeholder\n                    let totalUpdates = []\n                    let status = 'Offline'\n                    const connectTimes = []\n                    const updateTimes = []\n\n                    /**\n                     * Iterate through the networking inbound or gateway data\n                     */\n                    const inbound = response.dataplane.networking.inbound\n                    const gateway = response.dataplane.networking.gateway\n\n                    if (inbound || gateway) {\n                      if (inbound) {\n                        /** inbound */\n                        for (let i = 0; i < inbound.length; i++) {\n                          const rawTags = inbound[i].tags\n\n                          const final = []\n                          const tagKeys = Object.keys(rawTags)\n                          const tagVals = Object.values(rawTags)\n\n                          for (let x = 0; x < tagKeys.length; x++) {\n                            final.push({\n                              label: tagKeys[x],\n                              value: tagVals[x]\n                            })\n                          }\n\n                          tags = final\n                        }\n                      } else if (gateway) {\n                        /** gateway */\n                        const items = gateway.tags\n\n                        for (let i = 0; i < Object.keys(items).length; i++) {\n                          const final = []\n                          const tagKeys = Object.keys(items)\n                          const tagVals = Object.values(items)\n\n                          for (let x = 0; x < tagKeys.length; x++) {\n                            final.push({\n                              label: tagKeys[x],\n                              value: tagVals[x]\n                            })\n                          }\n\n                          tags = final\n                        }\n                      }\n                    } else {\n                      tags = 'none'\n                    }\n\n                    /**\n                     * Iterate through the subscriptions\n                     */\n                    if (response.dataplaneInsight.subscriptions && response.dataplaneInsight.subscriptions.length) {\n                      response.dataplaneInsight.subscriptions.forEach(item => {\n                        const responsesSent = item.status.total.responsesSent || 0\n                        const connectTime = item.connectTime || placeholder\n                        const lastUpdateTime = item.status.lastUpdateTime || placeholder\n                        const disconnectTime = item.disconnectTime || null\n\n                        totalUpdates.push(responsesSent)\n                        connectTimes.push(connectTime)\n                        updateTimes.push(lastUpdateTime)\n\n                        if (connectTime && connectTime.length && !disconnectTime) {\n                          status = 'Online'\n                        } else {\n                          status = 'Offline'\n                        }\n                      })\n\n                      // get the sum of total updates (with some precautions)\n                      totalUpdates = totalUpdates.reduce((a, b) => a + b)\n\n                      // select the most recent LAST CONNECTED timestamp\n                      const selectedTime = connectTimes.reduce((a, b) => {\n                        if (a && b) {\n                          return a.MeasureDate > b.MeasureDate ? a : b\n                        }\n\n                        return null\n                      })\n\n                      // select the most recent LAST UPDATED timestamnp\n                      const selectedUpdateTime = updateTimes.reduce((a, b) => {\n                        if (a && b) {\n                          return a.MeasureDate > b.MeasureDate ? a : b\n                        }\n\n                        return null\n                      })\n\n                      // format each reduced value as a date to compare against\n                      const selectedTimeAsDate = new Date(selectedTime)\n                      const selectedUpdateTimeAsDate = new Date(selectedUpdateTime)\n\n                      /**\n                       * @todo refactor this to use a function instead\n                       */\n\n                      // formatted time for LAST CONNECTED (if there is a value present)\n                      if (selectedTime && !isNaN(selectedTimeAsDate)) {\n                        lastConnected = humanReadableDate(selectedTimeAsDate)\n                      } else {\n                        lastConnected = 'never'\n                      }\n\n                      // formatted time for LAST UPDATED (if there is a value present)\n                      if (selectedUpdateTime && !isNaN(selectedUpdateTimeAsDate)) {\n                        lastUpdated = humanReadableDate(selectedUpdateTimeAsDate)\n                      } else {\n                        lastUpdated = 'never'\n                      }\n                    } else {\n                      // if there are no subscriptions, set them all to a fallback\n                      lastConnected = 'never'\n                      lastUpdated = 'never'\n                      totalUpdates = 0\n                    }\n\n                    // assemble the table data\n                    final.push({\n                      name: response.name,\n                      mesh: response.mesh,\n                      tags: tags,\n                      status: status,\n                      lastConnected: lastConnected,\n                      lastUpdated: lastUpdated,\n                      totalUpdates: totalUpdates,\n                      type: 'dataplane'\n                    })\n\n                    this.sortEntities(final)\n                  })\n                  .catch(error => {\n                    console.error(error)\n                  })\n              })\n\n              this.tableData.data = final\n              this.tableDataIsEmpty = false\n            } else {\n              this.tableData.data = []\n              this.tableDataIsEmpty = true\n\n              this.getEntity(null)\n            }\n          })\n          .catch(error => {\n            this.hasError = true\n\n            console.error(error)\n          })\n          .finally(() => {\n            setTimeout(() => {\n              this.isLoading = false\n            }, process.env.VUE_APP_DATA_TIMEOUT)\n          })\n      }\n\n      getDataplanes()\n    },\n    getEntity (entity) {\n      this.entityIsLoading = true\n      this.entityIsEmpty = false\n\n      const mesh = this.$route.params.mesh\n\n      if (entity && entity !== null) {\n        const entityMesh = (mesh === 'all')\n          ? entity.mesh\n          : mesh\n\n        return this.$api.getDataplaneFromMesh(entityMesh, entity.name)\n          .then(response => {\n            if (response) {\n              const selected = ['type', 'name', 'mesh', 'tags']\n\n              // determine between inbound and gateway modes\n              // and then get the tags from which condition applies.\n              const tagSrc = (response.networking.inbound && response.networking.inbound.length > 0)\n                ? response.networking.inbound[0].tags\n                : response.networking.gateway.tags\n\n              const newEntity = {\n                ...getSome(response, selected),\n                ...{\n                  tags: tagSrc\n                }\n              }\n\n              this.entity = newEntity\n\n              this.rawEntity = response\n            } else {\n              this.entity = null\n              this.entityIsEmpty = true\n            }\n          })\n          .catch(error => {\n            this.entityHasError = true\n            console.error(error)\n          })\n          .finally(() => {\n            setTimeout(() => {\n              this.entityIsLoading = false\n            }, process.env.VUE_APP_DATA_TIMEOUT)\n          })\n      } else {\n        setTimeout(() => {\n          this.entityIsEmpty = true\n          this.entityIsLoading = false\n        }, process.env.VUE_APP_DATA_TIMEOUT)\n      }\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.add-dp-button {\n  background-color: var(--logo-green) !important;\n}\n</style>\n"]}]}