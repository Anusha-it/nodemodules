{"remainingRequest":"/Users/ksagar/vueproj/sample/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ksagar/vueproj/sample/src/views/Wizard/views/Mesh.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/ksagar/vueproj/sample/src/views/Wizard/views/Mesh.vue","mtime":1589260598000},{"path":"/Users/ksagar/vueproj/sample/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/ksagar/vueproj/sample/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/ksagar/vueproj/sample/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/ksagar/vueproj/sample/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { mapGetters } from 'vuex'\nimport { rejectKeys } from '@/views/Wizard/helpers'\nimport updateStorage from '@/views/Wizard/mixins/updateStorage'\nimport FormatForCLI from '@/mixins/FormatForCLI'\nimport FormFragment from '@/views/Wizard/components/FormFragment'\nimport Tabs from '@/components/Utils/Tabs'\nimport StepSkeleton from '@/views/Wizard/components/StepSkeleton'\nimport CodeView from '@/components/Skeletons/CodeView'\nimport Scanner from '@/views/Wizard/components/Scanner'\n\n// schema for building code output\nimport meshSchema from '@/views/Wizard/schemas/Mesh'\n\nexport default {\n  name: 'MeshWizard',\n  metaInfo: {\n    title: 'Create a new Mesh'\n  },\n  components: {\n    FormFragment,\n    Tabs,\n    StepSkeleton,\n    CodeView,\n    Scanner\n  },\n  mixins: [\n    FormatForCLI,\n    updateStorage\n  ],\n  data () {\n    return {\n      schema: meshSchema,\n      steps: [\n        {\n          label: 'General & Security',\n          slug: 'general'\n        },\n        {\n          label: 'Logging',\n          slug: 'logging'\n        },\n        {\n          label: 'Tracing',\n          slug: 'tracing'\n        },\n        {\n          label: 'Metrics',\n          slug: 'metrics'\n        },\n        {\n          label: 'Install',\n          slug: 'complete'\n        }\n      ],\n      tabs: [\n        {\n          hash: '#kubernetes',\n          title: 'Kubernetes'\n        },\n        {\n          hash: '#universal',\n          title: 'Universal'\n        }\n      ],\n      sidebarContent: [\n        {\n          name: 'mesh'\n        },\n        {\n          name: 'did-you-know'\n        }\n      ],\n      formConditions: {\n        mtlsEnabled: false,\n        loggingEnabled: false,\n        tracingEnabled: false,\n        metricsEnabled: false,\n        loggingType: null\n      },\n      startScanner: false,\n      scanFound: false,\n      scanError: false,\n      isComplete: false,\n      nextDisabled: true,\n      validate: {\n        meshName: '',\n        meshLoggingBackend: ''\n      },\n      vmsg: []\n    }\n  },\n  computed: {\n    ...mapGetters({\n      title: 'getTagline',\n      version: 'getVersion',\n      environment: 'getEnvironment',\n      formData: 'getStoredWizardData',\n      selectedTab: 'getSelectedTab'\n    }),\n\n    // this exists because the browser is stubborn and holds onto this\n    // data even if it's not present in localStorage\n    getCleanMeshName () {\n      const data = this.$store.getters.getStoredWizardData\n\n      if (data) {\n        return data.meshName\n      } else {\n        return null\n      }\n    },\n\n    // Our generated code output\n    codeOutput () {\n      const schema = this.schema\n      const schemaNew = Object.assign({}, schema)\n      const newData = this.formData\n\n      // if there is no data set yet, do nothing\n      if (!newData) return\n\n      /**\n       * Assign new values to our schema\n       */\n\n      // conditionals\n      const hasMtls = newData.meshMtls || false\n      const hasLogging = newData.meshLoggingStatus || false\n      const hasTracing = newData.meshTracingStatus || false\n      const hasMetrics = newData.meshMetricsStatus || false\n\n      // filter options\n      const featureStatus = {\n        mtls: hasMtls,\n        logging: hasLogging,\n        tracing: hasTracing,\n        metrics: hasMetrics\n      }\n\n      // define the features we are going to omit from our object\n      const filteredFeatures = []\n\n      Object.entries(featureStatus).forEach(r => {\n        const condition = r[1]\n        const value = r[0]\n\n        if (condition) {\n          filteredFeatures.filter(i => i !== value)\n        } else {\n          filteredFeatures.push(value)\n        }\n      })\n\n      /**\n       * mTLS\n       */\n      if (hasMtls) {\n        schemaNew.spec.mtls.enabled = true\n        schemaNew.spec.mtls.ca = {\n          [newData.meshCA || 'builtin']: {}\n        }\n      }\n\n      /**\n       * Logging\n       */\n\n      if (hasLogging) {\n        const loggingObj = schemaNew.spec.logging.backends[0]\n        const fallbackFormat = loggingObj.format\n\n        loggingObj.name = newData.meshLoggingBackend\n        loggingObj.format = newData.meshLoggingBackendFormat || fallbackFormat\n\n        if (newData.meshLoggingType === 'tcp') {\n          if (loggingObj.file) {\n            delete loggingObj.file\n          }\n\n          loggingObj.tcp = {\n            address: newData.meshLoggingAddress || '127.0.0.1:5000'\n          }\n        } else if (newData.meshLoggingType === 'file') {\n          if (loggingObj.tcp) {\n            delete loggingObj.tcp\n          }\n\n          loggingObj.file = {\n            path: newData.meshLoggingPath\n          }\n        }\n      }\n\n      /**\n       * Tracing\n       */\n      if (hasTracing) {\n        const tracingObj = schemaNew.spec.tracing\n\n        tracingObj.defaultBackend = newData.meshTracingBackend\n        tracingObj.backends[0].name = newData.meshTracingBackend\n        tracingObj.backends[0].sampling = newData.meshTracingSampling || 100\n        tracingObj.backends[0].zipkin.url = newData.meshTracingZipkinURL\n      }\n\n      /**\n       * Metrics\n       */\n      if (hasMetrics) {\n        const metricsObj = schemaNew.spec.metrics\n\n        metricsObj.prometheus.port = newData.meshMetricsDataplanePort || 5670\n        metricsObj.prometheus.path = newData.meshMetricsDataplanePath || '/metrics'\n      }\n\n      // now we clean up our output based on the above conditions\n      const schemaClean = rejectKeys(schemaNew.spec, filteredFeatures)\n\n      // Type and Name\n      let meshType\n\n      if (this.selectedTab === '#kubernetes') {\n        // Kubernetes\n        meshType = {\n          apiVersion: 'kuma.io/v1alpha1',\n          kind: 'Mesh',\n          metadata: {\n            name: newData.meshName\n          }\n        }\n      } else {\n        // Universal\n        meshType = {\n          type: 'Mesh',\n          name: newData.meshName\n        }\n      }\n\n      /**\n       * Finalized output\n       */\n\n      let codeBlock\n\n      if (this.selectedTab === '#kubernetes') {\n        codeBlock = { ...meshType, spec: { ...schemaClean } }\n      } else {\n        codeBlock = { ...meshType, ...schemaClean }\n      }\n\n      const assembledBlock = this.formatForCLI(codeBlock)\n\n      return assembledBlock\n    }\n  },\n  watch: {\n    'validate.meshName' (value) {\n      this.validate.meshName = value\n      this.validateMeshName(value)\n    }\n  },\n  mounted () {\n    // this ensures the Wizard tab is actively set based on\n    // the user's Kuma environment (Universal or Kubernetes)\n    this.$store.dispatch('updateSelectedTab', `#${this.environment}`)\n  },\n  methods: {\n    validateMeshName (value) {\n      if (!value || value === '') {\n        this.vmsg.meshName = 'A Mesh name is required to proceed'\n        this.nextDisabled = true\n      } else {\n        this.vmsg.meshName = ''\n        this.nextDisabled = false\n      }\n    },\n    scanForEntity () {\n      // get our entity from the VueX store\n      const entity = this.$store.getters.getStoredWizardData.meshName\n\n      // reset things if the user is starting over\n      this.scanComplete = false\n      this.scanError = false\n\n      // do nothing if there's nothing found\n      if (!entity) return\n\n      // this.$api.getMesh(entity)\n      this.$api.getMesh(entity)\n        .then(response => {\n          if (response && response.name.length > 0) {\n            this.isRunning = true\n            this.scanFound = true\n          } else {\n            this.scanError = true\n          }\n        })\n        .catch(error => {\n          this.scanError = true\n\n          console.error(error)\n        })\n        .finally(() => {\n          this.scanComplete = true\n        })\n    }\n  }\n}\n",{"version":3,"sources":["Mesh.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Mesh.vue","sourceRoot":"src/views/Wizard/views","sourcesContent":["<template>\n  <div class=\"wizard\">\n    <div class=\"wizard__content\">\n      <StepSkeleton\n        :steps=\"steps\"\n        :advance-check=\"true\"\n        :sidebar-content=\"sidebarContent\"\n        :footer-enabled=\"scanFound === false\"\n        :next-disabled=\"nextDisabled\"\n      >\n        <!-- step content -->\n        <template slot=\"general\">\n          <p>\n            Welcome to the wizard for creating a new Mesh entity in Kuma.\n            We will be providing you with a few steps that will get you started.\n          </p>\n          <p>\n            As you know, the Kuma GUI is read-only, so at the end of this wizard\n            we will be generating the configuration that you can apply with either\n            <code>kubectl</code> (if you are running in Kubernetes mode) or\n            kumactl / API (if you are running in Universal mode).\n          </p>\n\n          <h3>\n            To get started, please fill-in the following information:\n          </h3>\n\n          <KCard\n            class=\"my-6 k-card--small\"\n            title=\"Mesh Information\"\n            has-shadow\n          >\n            <template slot=\"body\">\n              <FormFragment\n                title=\"Mesh name\"\n                for-attr=\"mesh-name\"\n              >\n                <input\n                  id=\"mesh-name\"\n                  v-model=\"validate.meshName\"\n                  type=\"text\"\n                  class=\"k-input w-100\"\n                  placeholder=\"your-mesh-name\"\n                  required\n                  @change=\"updateStorage('meshName', $event.target.value)\"\n                >\n                <KAlert\n                  v-if=\"vmsg.meshName\"\n                  appearance=\"danger\"\n                  size=\"small\"\n                  :alert-message=\"vmsg.meshName\"\n                />\n              </FormFragment>\n\n              <FormFragment title=\"Mutual TLS\">\n                <label class=\"k-input-label mx-2\">\n                  <input\n                    ref=\"mtlsDisabled\"\n                    value=\"disabled\"\n                    name=\"mtls\"\n                    type=\"radio\"\n                    class=\"k-input mr-2\"\n                    :checked=\"formConditions.mtlsEnabled === false\"\n                    @change=\"\n                      updateStorage('meshMtls', false);\n                      formConditions.mtlsEnabled = false\n                    \"\n                  >\n                  <span>Disabled</span>\n                </label>\n                <label class=\"k-input-label mx-2\">\n                  <input\n                    id=\"mtls-enabled\"\n                    value=\"enabled\"\n                    name=\"mtls\"\n                    type=\"radio\"\n                    class=\"k-input mr-2\"\n                    :checked=\"formConditions.mtlsEnabled === true\"\n                    @change=\"\n                      updateStorage('meshMtls', true);\n                      updateStorage('meshCA', 'builtin');\n                      formConditions.mtlsEnabled = true\"\n                  >\n                  <span>Enabled</span>\n                </label>\n              </FormFragment>\n\n              <FormFragment\n                v-if=\"formConditions.mtlsEnabled === true\"\n                title=\"Certificate Authority\"\n                for-attr=\"certificate-authority\"\n              >\n                <select\n                  id=\"certificate-authority\"\n                  class=\"k-input w-100\"\n                  name=\"certificate-authority\"\n                  @change=\"updateStorage('meshCA', $event.target.value)\"\n                >\n                  <option\n                    value=\"builtin\"\n                    :selected=\"(getStorageItem('meshCA') === 'builtin') ? true : false\"\n                  >\n                    builtin\n                  </option>\n                  <option\n                    value=\"provided\"\n                    :selected=\"(getStorageItem('meshCA') === 'provided') ? true : false\"\n                  >\n                    provided\n                  </option>\n                  <option\n                    value=\"vault\"\n                    :selected=\"(getStorageItem('meshCA') === 'vault') ? true : false\"\n                  >\n                    vault\n                  </option>\n                </select>\n                <p class=\"help\">\n                  If you've enabled mTLS, you must select a CA.\n                </p>\n              </FormFragment>\n            </template>\n          </KCard>\n        </template>\n        <template slot=\"logging\">\n          <h3>\n            Setup Logging\n          </h3>\n          <p>\n            You can setup as many logging backends as you need that you can later\n            use to log traffic via the &quot;TrafficLog&quot; policy. In this wizard,\n            we allow you to configure one backend, but you can add more manually\n            if you wish.\n          </p>\n          <KCard\n            class=\"my-6 k-card--small\"\n            title=\"Logging Configuration\"\n            has-shadow\n          >\n            <template slot=\"body\">\n              <FormFragment title=\"Logging\">\n                <label class=\"k-input-label mx-2\">\n                  <input\n                    id=\"logging-disabled\"\n                    value=\"disabled\"\n                    name=\"logging\"\n                    type=\"radio\"\n                    class=\"k-input mr-2\"\n                    :checked=\"formConditions.loggingEnabled === false\"\n                    @change=\"updateStorage('meshLoggingStatus', false); formConditions.loggingEnabled = false\"\n                  >\n                  <span>Disabled</span>\n                </label>\n                <label class=\"k-input-label mx-2\">\n                  <input\n                    id=\"logging-enabled\"\n                    value=\"enabled\"\n                    name=\"logging\"\n                    type=\"radio\"\n                    class=\"k-input mr-2\"\n                    :checked=\"formConditions.loggingEnabled === true\"\n                    @change=\"\n                      updateStorage('meshLoggingStatus', true);\n                      updateStorage('meshLoggingType', 'tcp');\n                      formConditions.loggingEnabled = true\n                      formConditions.loggingType = 'tcp'\"\n                  >\n                  <span>Enabled</span>\n                </label>\n              </FormFragment>\n              <FormFragment\n                v-if=\"formConditions.loggingEnabled === true\"\n                title=\"Backend name\"\n              >\n                <input\n                  id=\"backend-name\"\n                  type=\"text\"\n                  class=\"k-input w-100\"\n                  placeholder=\"your-backend-name\"\n                  :value=\"getStorageItem('meshLoggingBackend')\"\n                  @change=\"updateStorage('meshLoggingBackend', $event.target.value)\"\n                >\n              </FormFragment>\n              <div v-if=\"formConditions.loggingEnabled === true\">\n                <FormFragment title=\"Type\">\n                  <select\n                    id=\"logging-type\"\n                    ref=\"loggingTypeSelect\"\n                    class=\"k-input w-100\"\n                    name=\"logging-type\"\n                    @change=\"updateStorage('meshLoggingType', $event.target.value); formConditions.loggingType = $event.target.value\"\n                  >\n                    <option\n                      value=\"tcp\"\n                      :selected=\"(getStorageItem('meshLoggingType') === 'tcp') ? true : false\"\n                    >\n                      TCP\n                    </option>\n                    <option\n                      value=\"file\"\n                      :selected=\"(getStorageItem('meshLoggingType') === 'file') ? true : false\"\n                    >\n                      File\n                    </option>\n                  </select>\n                </FormFragment>\n                <!-- if the format type is File -->\n                <FormFragment\n                  v-if=\"formConditions.loggingType === 'file'\"\n                  title=\"Path\"\n                  for-attr=\"backend-address\"\n                >\n                  <input\n                    id=\"backend-address\"\n                    type=\"text\"\n                    class=\"k-input w-100\"\n                    :value=\"getStorageItem('meshLoggingPath')\"\n                    @change=\"updateStorage('meshLoggingPath', $event.target.value)\"\n                  >\n                </FormFragment>\n                <!-- if the format type is TCP -->\n                <FormFragment\n                  v-if=\"formConditions.loggingType === 'tcp'\"\n                  title=\"Address\"\n                  for-attr=\"backend-address\"\n                >\n                  <input\n                    id=\"backend-address\"\n                    type=\"text\"\n                    class=\"k-input w-100\"\n                    :value=\"getStorageItem('meshLoggingAddress') || '127.0.0.1:5000'\"\n                    @change=\"updateStorage('meshLoggingAddress', $event.target.value)\"\n                  >\n                </FormFragment>\n                <FormFragment\n                  title=\"Format\"\n                  for-attr=\"backend-format\"\n                >\n                  <textarea\n                    id=\"backend-format\"\n                    class=\"k-input w-100 code-sample\"\n                    rows=\"12\"\n                    @change=\"updateStorage('meshLoggingBackendFormat', ($event.target.value).trim())\"\n                  >\n                    { \"start_time\": \"%START_TIME%\", \"source\": \"%KUMA_SOURCE_SERVICE%\", \"destination\": \"%KUMA_DESTINATION_SERVICE%\", \"source_address\": \"%KUMA_SOURCE_ADDRESS_WITHOUT_PORT%\", \"destination_address\": \"%UPSTREAM_HOST%\", \"duration_millis\": \"%DURATION%\", \"bytes_received\": \"%BYTES_RECEIVED%\", \"bytes_sent\": \"%BYTES_SENT%\" }\n                    </textarea>\n                </FormFragment>\n              </div>\n            </template>\n          </KCard>\n        </template>\n        <template slot=\"tracing\">\n          <h3>\n            Setup Tracing\n          </h3>\n          <p>\n            You can setup as many tracing backends as you need that you can later\n            use to log traffic via the &quot;TrafficTrace&quot; policy. In this\n            wizard we allow you to configure one backend, but you can add more\n            manually as you wish.\n          </p>\n          <KCard\n            class=\"my-6 k-card--small\"\n            title=\"Tracing Configuration\"\n            has-shadow\n          >\n            <template slot=\"body\">\n              <FormFragment\n                title=\"Tracing\"\n              >\n                <label class=\"k-input-label mx-2\">\n                  <input\n                    id=\"tracing-disabled\"\n                    value=\"disabled\"\n                    name=\"tracing\"\n                    type=\"radio\"\n                    class=\"k-input mr-2\"\n                    :checked=\"formConditions.tracingEnabled === false\"\n                    @change=\"updateStorage('meshTracingStatus', false); formConditions.tracingEnabled = false\"\n                  >\n                  <span>Disabled</span>\n                </label>\n                <label class=\"k-input-label mx-2\">\n                  <input\n                    id=\"tracing-enabled\"\n                    value=\"enabled\"\n                    name=\"tracing\"\n                    type=\"radio\"\n                    class=\"k-input mr-2\"\n                    :checked=\"formConditions.tracingEnabled === true\"\n                    @change=\"\n                      updateStorage('meshTracingStatus', true);\n                      updateStorage('meshTracingType', 'zipkin')\n                      formConditions.tracingEnabled = true\"\n                  >\n                  <span>Enabled</span>\n                </label>\n              </FormFragment>\n\n              <FormFragment\n                v-if=\"formConditions.tracingEnabled === true\"\n                title=\"Backend name\"\n                for-attr=\"tracing-backend-name\"\n              >\n                <input\n                  id=\"tracing-backend-name\"\n                  type=\"text\"\n                  class=\"k-input w-100\"\n                  placeholder=\"your-tracing-backend-name\"\n                  :value=\"getStorageItem('meshTracingBackend')\"\n                  @change=\"updateStorage('meshTracingBackend', $event.target.value)\"\n                >\n              </FormFragment>\n\n              <FormFragment\n                v-if=\"formConditions.tracingEnabled === true\"\n                title=\"Type\"\n                for-attr=\"tracing-type\"\n              >\n                <select\n                  id=\"tracing-type\"\n                  class=\"k-input w-100\"\n                  name=\"tracing-type\"\n                  @change=\"updateStorage('meshTracingType', $event.target.value)\"\n                >\n                  <option\n                    value=\"zipkin\"\n                    :selected=\"(getStorageItem('meshTracingType') === 'zipkin') ? true : false\"\n                  >\n                    Zipkin\n                  </option>\n                </select>\n              </FormFragment>\n\n              <FormFragment\n                v-if=\"formConditions.tracingEnabled === true\"\n                title=\"Sampling\"\n                for-attr=\"tracing-sampling\"\n              >\n                <input\n                  id=\"tracing-sampling\"\n                  type=\"number\"\n                  class=\"k-input w-100\"\n                  :value=\"getStorageItem('meshTracingSampling') || 99.9\"\n                  step=\"0.1\"\n                  min=\"0\"\n                  max=\"100\"\n                  @change=\"updateStorage('meshTracingSampling', $event.target.value)\"\n                >\n              </FormFragment>\n\n              <FormFragment\n                v-if=\"formConditions.tracingEnabled === true\"\n                title=\"URL\"\n                for-attr=\"tracing-zipkin-url\"\n              >\n                <input\n                  id=\"tracing-zipkin-url\"\n                  type=\"text\"\n                  class=\"k-input w-100\"\n                  placeholder=\"your Zipkin URL\"\n                  :value=\"getStorageItem('meshTracingZipkinURL')\"\n                  @change=\"updateStorage('meshTracingZipkinURL', $event.target.value)\"\n                >\n              </FormFragment>\n            </template>\n          </KCard>\n        </template>\n        <template slot=\"metrics\">\n          <h3>\n            Setup Metrics\n          </h3>\n          <p>\n            You can expose metrics from every data-plane on a configurable path\n            and port that a metrics service, like Prometheus, can use to fetch them.\n          </p>\n          <KCard\n            class=\"my-6 k-card--small\"\n            title=\"Metrics Configuration\"\n            has-shadow\n          >\n            <template slot=\"body\">\n              <FormFragment\n                title=\"Metrics\"\n              >\n                <label class=\"k-input-label mx-2\">\n                  <input\n                    id=\"metrics-disabled\"\n                    value=\"disabled\"\n                    name=\"metrics\"\n                    type=\"radio\"\n                    class=\"k-input mr-2\"\n                    :checked=\"formConditions.metricsEnabled === false\"\n                    @change=\"updateStorage('meshMetricsStatus', false); formConditions.metricsEnabled = false\"\n                  >\n                  <span>Disabled</span>\n                </label>\n                <label class=\"k-input-label mx-2\">\n                  <input\n                    id=\"metrics-enabled\"\n                    value=\"enabled\"\n                    name=\"metrics\"\n                    type=\"radio\"\n                    class=\"k-input mr-2\"\n                    :checked=\"formConditions.metricsEnabled === true\"\n                    @change=\"\n                      updateStorage('meshMetricsStatus', true);\n                      updateStorage('meshMetricsType', 'prometheus')\n                      formConditions.metricsEnabled = true\"\n                  >\n                  <span>Enabled</span>\n                </label>\n              </FormFragment>\n              <FormFragment\n                v-if=\"formConditions.metricsEnabled === true\"\n                title=\"Type\"\n                for-attr=\"metrics-type\"\n              >\n                <select\n                  id=\"metrics-type\"\n                  class=\"k-input w-100\"\n                  name=\"metrics-type\"\n                  @change=\"updateStorage('meshMetricsType', $event.target.value)\"\n                >\n                  <option\n                    value=\"prometheus\"\n                    :selected=\"(getStorageItem('meshMetricsType') === 'prometheus') ? true : false\"\n                  >\n                    Prometheus\n                  </option>\n                </select>\n              </FormFragment>\n              <FormFragment\n                v-if=\"formConditions.metricsEnabled === true\"\n                title=\"Dataplane port\"\n                for-attr=\"metrics-dataplane-port\"\n              >\n                <input\n                  id=\"metrics-dataplane-port\"\n                  type=\"number\"\n                  class=\"k-input w-100\"\n                  step=\"1\"\n                  min=\"0\"\n                  max=\"65535\"\n                  placeholder=\"1234\"\n                  :value=\"getStorageItem('meshMetricsDataplanePort') || '5670'\"\n                  @change=\"updateStorage('meshMetricsDataplanePort', $event.target.value)\"\n                >\n              </FormFragment>\n              <FormFragment\n                v-if=\"formConditions.metricsEnabled === true\"\n                title=\"Dataplane path\"\n                for-attr=\"metrics-dataplane-path\"\n              >\n                <input\n                  id=\"metrics-dataplane-path\"\n                  type=\"text\"\n                  class=\"k-input w-100\"\n                  :value=\"getStorageItem('meshMetricsDataplanePath') || '/metrics'\"\n                  @change=\"updateStorage('meshMetricsDataplanePath', $event.target.value)\"\n                >\n              </FormFragment>\n            </template>\n          </KCard>\n        </template>\n        <template slot=\"complete\">\n          <div v-if=\"codeOutput\">\n            <div v-if=\"scanFound === false\">\n              <h3>\n                Install a new Mesh\n              </h3>\n              <p>\n                Since the Kuma GUI is read-only mode to follow Ops best practices,\n                please execute the following command in your shell to create the entity.\n                Kuma will automatically detect when the new entity has been created.\n              </p>\n              <Tabs\n                :loaders=\"false\"\n                :tabs=\"tabs\"\n                :has-border=\"true\"\n                :initial-tab-override=\"environment\"\n              >\n                <template slot=\"kubernetes\">\n                  <CodeView\n                    title=\"Kubernetes\"\n                    copy-button-text=\"Copy Command to Clipboard\"\n                    lang=\"bash\"\n                    :content=\"codeOutput\"\n                  />\n                </template>\n                <template slot=\"universal\">\n                  <CodeView\n                    title=\"Universal\"\n                    copy-button-text=\"Copy Command to Clipboard\"\n                    lang=\"bash\"\n                    :content=\"codeOutput\"\n                  />\n                </template>\n              </Tabs>\n            </div>\n            <Scanner\n              :loader-function=\"scanForEntity\"\n              :should-start=\"true\"\n              :has-error=\"scanError\"\n              :can-complete=\"scanFound\"\n            >\n              <!-- loading -->\n              <template slot=\"loading-title\">\n                <h3>Searching&hellip;</h3>\n              </template>\n              <template slot=\"loading-content\">\n                <p>We are looking for your mesh.</p>\n              </template>\n              <!-- complete -->\n              <template slot=\"complete-title\">\n                <h3>Done!</h3>\n              </template>\n              <template slot=\"complete-content\">\n                <p>\n                  Your Mesh <strong v-if=\"formData.meshName\">{{ formData.meshName }}</strong> was found!\n                </p>\n                <p>\n                  <KButton\n                    appearance=\"primary\"\n                    :to=\"{ name: 'all-meshes' }\"\n                  >\n                    See Meshes\n                  </KButton>\n                </p>\n              </template>\n              <!-- error -->\n              <template slot=\"error-title\">\n                <h3>Mesh not found</h3>\n              </template>\n              <template slot=\"error-content\">\n                <p>We were unable to find your mesh.</p>\n              </template>\n            </Scanner>\n          </div>\n          <KAlert\n            v-else\n            appearance=\"danger\"\n          >\n            <template slot=\"alertMessage\">\n              <p>\n                You haven't filled any data out yet! Please return to the first\n                step and fill out your information.\n              </p>\n            </template>\n          </KAlert>\n        </template>\n\n        <!-- sidebar content -->\n        <template slot=\"mesh\">\n          <h3>Mesh</h3>\n          <p>\n            In {{ title }}, a Mesh entity allows you to define an isolated environment\n            for your data-planes and policies. It's isolated because the mTLS CA\n            you choose can be different from the one configured for our Meshes.\n            Ideally, you will have either a large Mesh with all the workloads, or\n            one Mesh per application for better isolation.\n          </p>\n          <p>\n            <a\n              :href=\"`https://kuma.io/docs/${version}/policies/mesh/`\"\n              target=\"_blank\"\n            >\n              Learn More\n            </a>\n          </p>\n        </template>\n        <template slot=\"did-you-know\">\n          <h3>Did You Know?</h3>\n          <p>\n            As you know, the GUI is read-only, but it will be providing instructions\n            to create a new Mesh and verify everything worked well.\n          </p>\n        </template>\n      </StepSkeleton>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { mapGetters } from 'vuex'\nimport { rejectKeys } from '@/views/Wizard/helpers'\nimport updateStorage from '@/views/Wizard/mixins/updateStorage'\nimport FormatForCLI from '@/mixins/FormatForCLI'\nimport FormFragment from '@/views/Wizard/components/FormFragment'\nimport Tabs from '@/components/Utils/Tabs'\nimport StepSkeleton from '@/views/Wizard/components/StepSkeleton'\nimport CodeView from '@/components/Skeletons/CodeView'\nimport Scanner from '@/views/Wizard/components/Scanner'\n\n// schema for building code output\nimport meshSchema from '@/views/Wizard/schemas/Mesh'\n\nexport default {\n  name: 'MeshWizard',\n  metaInfo: {\n    title: 'Create a new Mesh'\n  },\n  components: {\n    FormFragment,\n    Tabs,\n    StepSkeleton,\n    CodeView,\n    Scanner\n  },\n  mixins: [\n    FormatForCLI,\n    updateStorage\n  ],\n  data () {\n    return {\n      schema: meshSchema,\n      steps: [\n        {\n          label: 'General & Security',\n          slug: 'general'\n        },\n        {\n          label: 'Logging',\n          slug: 'logging'\n        },\n        {\n          label: 'Tracing',\n          slug: 'tracing'\n        },\n        {\n          label: 'Metrics',\n          slug: 'metrics'\n        },\n        {\n          label: 'Install',\n          slug: 'complete'\n        }\n      ],\n      tabs: [\n        {\n          hash: '#kubernetes',\n          title: 'Kubernetes'\n        },\n        {\n          hash: '#universal',\n          title: 'Universal'\n        }\n      ],\n      sidebarContent: [\n        {\n          name: 'mesh'\n        },\n        {\n          name: 'did-you-know'\n        }\n      ],\n      formConditions: {\n        mtlsEnabled: false,\n        loggingEnabled: false,\n        tracingEnabled: false,\n        metricsEnabled: false,\n        loggingType: null\n      },\n      startScanner: false,\n      scanFound: false,\n      scanError: false,\n      isComplete: false,\n      nextDisabled: true,\n      validate: {\n        meshName: '',\n        meshLoggingBackend: ''\n      },\n      vmsg: []\n    }\n  },\n  computed: {\n    ...mapGetters({\n      title: 'getTagline',\n      version: 'getVersion',\n      environment: 'getEnvironment',\n      formData: 'getStoredWizardData',\n      selectedTab: 'getSelectedTab'\n    }),\n\n    // this exists because the browser is stubborn and holds onto this\n    // data even if it's not present in localStorage\n    getCleanMeshName () {\n      const data = this.$store.getters.getStoredWizardData\n\n      if (data) {\n        return data.meshName\n      } else {\n        return null\n      }\n    },\n\n    // Our generated code output\n    codeOutput () {\n      const schema = this.schema\n      const schemaNew = Object.assign({}, schema)\n      const newData = this.formData\n\n      // if there is no data set yet, do nothing\n      if (!newData) return\n\n      /**\n       * Assign new values to our schema\n       */\n\n      // conditionals\n      const hasMtls = newData.meshMtls || false\n      const hasLogging = newData.meshLoggingStatus || false\n      const hasTracing = newData.meshTracingStatus || false\n      const hasMetrics = newData.meshMetricsStatus || false\n\n      // filter options\n      const featureStatus = {\n        mtls: hasMtls,\n        logging: hasLogging,\n        tracing: hasTracing,\n        metrics: hasMetrics\n      }\n\n      // define the features we are going to omit from our object\n      const filteredFeatures = []\n\n      Object.entries(featureStatus).forEach(r => {\n        const condition = r[1]\n        const value = r[0]\n\n        if (condition) {\n          filteredFeatures.filter(i => i !== value)\n        } else {\n          filteredFeatures.push(value)\n        }\n      })\n\n      /**\n       * mTLS\n       */\n      if (hasMtls) {\n        schemaNew.spec.mtls.enabled = true\n        schemaNew.spec.mtls.ca = {\n          [newData.meshCA || 'builtin']: {}\n        }\n      }\n\n      /**\n       * Logging\n       */\n\n      if (hasLogging) {\n        const loggingObj = schemaNew.spec.logging.backends[0]\n        const fallbackFormat = loggingObj.format\n\n        loggingObj.name = newData.meshLoggingBackend\n        loggingObj.format = newData.meshLoggingBackendFormat || fallbackFormat\n\n        if (newData.meshLoggingType === 'tcp') {\n          if (loggingObj.file) {\n            delete loggingObj.file\n          }\n\n          loggingObj.tcp = {\n            address: newData.meshLoggingAddress || '127.0.0.1:5000'\n          }\n        } else if (newData.meshLoggingType === 'file') {\n          if (loggingObj.tcp) {\n            delete loggingObj.tcp\n          }\n\n          loggingObj.file = {\n            path: newData.meshLoggingPath\n          }\n        }\n      }\n\n      /**\n       * Tracing\n       */\n      if (hasTracing) {\n        const tracingObj = schemaNew.spec.tracing\n\n        tracingObj.defaultBackend = newData.meshTracingBackend\n        tracingObj.backends[0].name = newData.meshTracingBackend\n        tracingObj.backends[0].sampling = newData.meshTracingSampling || 100\n        tracingObj.backends[0].zipkin.url = newData.meshTracingZipkinURL\n      }\n\n      /**\n       * Metrics\n       */\n      if (hasMetrics) {\n        const metricsObj = schemaNew.spec.metrics\n\n        metricsObj.prometheus.port = newData.meshMetricsDataplanePort || 5670\n        metricsObj.prometheus.path = newData.meshMetricsDataplanePath || '/metrics'\n      }\n\n      // now we clean up our output based on the above conditions\n      const schemaClean = rejectKeys(schemaNew.spec, filteredFeatures)\n\n      // Type and Name\n      let meshType\n\n      if (this.selectedTab === '#kubernetes') {\n        // Kubernetes\n        meshType = {\n          apiVersion: 'kuma.io/v1alpha1',\n          kind: 'Mesh',\n          metadata: {\n            name: newData.meshName\n          }\n        }\n      } else {\n        // Universal\n        meshType = {\n          type: 'Mesh',\n          name: newData.meshName\n        }\n      }\n\n      /**\n       * Finalized output\n       */\n\n      let codeBlock\n\n      if (this.selectedTab === '#kubernetes') {\n        codeBlock = { ...meshType, spec: { ...schemaClean } }\n      } else {\n        codeBlock = { ...meshType, ...schemaClean }\n      }\n\n      const assembledBlock = this.formatForCLI(codeBlock)\n\n      return assembledBlock\n    }\n  },\n  watch: {\n    'validate.meshName' (value) {\n      this.validate.meshName = value\n      this.validateMeshName(value)\n    }\n  },\n  mounted () {\n    // this ensures the Wizard tab is actively set based on\n    // the user's Kuma environment (Universal or Kubernetes)\n    this.$store.dispatch('updateSelectedTab', `#${this.environment}`)\n  },\n  methods: {\n    validateMeshName (value) {\n      if (!value || value === '') {\n        this.vmsg.meshName = 'A Mesh name is required to proceed'\n        this.nextDisabled = true\n      } else {\n        this.vmsg.meshName = ''\n        this.nextDisabled = false\n      }\n    },\n    scanForEntity () {\n      // get our entity from the VueX store\n      const entity = this.$store.getters.getStoredWizardData.meshName\n\n      // reset things if the user is starting over\n      this.scanComplete = false\n      this.scanError = false\n\n      // do nothing if there's nothing found\n      if (!entity) return\n\n      // this.$api.getMesh(entity)\n      this.$api.getMesh(entity)\n        .then(response => {\n          if (response && response.name.length > 0) {\n            this.isRunning = true\n            this.scanFound = true\n          } else {\n            this.scanError = true\n          }\n        })\n        .catch(error => {\n          this.scanError = true\n\n          console.error(error)\n        })\n        .finally(() => {\n          this.scanComplete = true\n        })\n    }\n  }\n}\n</script>\n"]}]}