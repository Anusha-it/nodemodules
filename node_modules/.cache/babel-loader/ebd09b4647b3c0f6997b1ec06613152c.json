{"remainingRequest":"/Users/ksagar/vueproj/sample/node_modules/babel-loader/lib/index.js!/Users/ksagar/vueproj/sample/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/ksagar/vueproj/sample/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ksagar/vueproj/sample/src/views/Entities/Dataplanes.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/ksagar/vueproj/sample/src/views/Entities/Dataplanes.vue","mtime":1589260598000},{"path":"/Users/ksagar/vueproj/sample/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/ksagar/vueproj/sample/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/ksagar/vueproj/sample/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/ksagar/vueproj/sample/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/es7.object.values\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\nimport _defineProperty from \"/Users/ksagar/vueproj/sample/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { mapGetters } from 'vuex';\nimport { getSome, humanReadableDate, getOffset } from '@/helpers';\nimport sortEntities from '@/mixins/EntitySorter';\nimport FrameSkeleton from '@/components/Skeletons/FrameSkeleton';\nimport Pagination from '@/components/Pagination';\nimport DataOverview from '@/components/Skeletons/DataOverview';\nimport Tabs from '@/components/Utils/Tabs';\nimport YamlView from '@/components/Skeletons/YamlView';\nimport LabelList from '@/components/Utils/LabelList';\nexport default {\n  name: 'Dataplanes',\n  metaInfo: {\n    title: 'Dataplanes'\n  },\n  components: {\n    FrameSkeleton: FrameSkeleton,\n    Pagination: Pagination,\n    DataOverview: DataOverview,\n    Tabs: Tabs,\n    YamlView: YamlView,\n    LabelList: LabelList\n  },\n  mixins: [sortEntities],\n  data: function data() {\n    return {\n      isLoading: true,\n      isEmpty: false,\n      hasError: false,\n      entityIsLoading: true,\n      entityIsEmpty: false,\n      entityHasError: false,\n      tableDataIsEmpty: false,\n      empty_state: {\n        title: 'No Data',\n        message: 'There are no Dataplanes present.'\n      },\n      tableData: {\n        headers: [{\n          key: 'actions',\n          hideLabel: true\n        }, {\n          label: 'Status',\n          key: 'status'\n        }, {\n          label: 'Name',\n          key: 'name'\n        }, {\n          label: 'Mesh',\n          key: 'mesh'\n        }, {\n          label: 'Tags',\n          key: 'tags'\n        }, {\n          label: 'Last Connected',\n          key: 'lastConnected'\n        }, {\n          label: 'Last Updated',\n          key: 'lastUpdated'\n        }, {\n          label: 'Total Updates',\n          key: 'totalUpdates'\n        }],\n        data: []\n      },\n      tabs: [{\n        hash: '#overview',\n        title: 'Overview'\n      }, {\n        hash: '#yaml',\n        title: 'YAML'\n      }],\n      entity: null,\n      rawEntity: null,\n      firstEntity: null,\n      pageSize: this.$pageSize,\n      pageOffset: null,\n      next: null,\n      hasNext: false,\n      previous: []\n    };\n  },\n  computed: _objectSpread(_objectSpread({}, mapGetters({\n    environment: 'getEnvironment'\n  })), {}, {\n    tabGroupTitle: function tabGroupTitle() {\n      var entity = this.entity;\n\n      if (entity) {\n        return \"Dataplane: \".concat(entity.name);\n      } else {\n        return null;\n      }\n    },\n    entityOverviewTitle: function entityOverviewTitle() {\n      var entity = this.entity;\n\n      if (entity) {\n        return \"Entity Overview for \".concat(entity.name);\n      } else {\n        return null;\n      }\n    },\n    dataplaneWizardRoute: function dataplaneWizardRoute() {\n      // we change the route to the Dataplane\n      // wizard based on environment.\n      if (this.environment === 'universal') {\n        return {\n          name: 'universal-dataplane'\n        };\n      } else {\n        return {\n          name: 'kubernetes-dataplane'\n        };\n      }\n    }\n  }),\n  watch: {\n    '$route': function $route(to, from) {\n      this.loadData();\n    }\n  },\n  beforeMount: function beforeMount() {\n    this.loadData();\n  },\n  methods: {\n    init: function init() {\n      this.loadData();\n    },\n    goToPreviousPage: function goToPreviousPage() {\n      this.pageOffset = this.previous.pop();\n      this.next = null;\n      this.loadData();\n    },\n    goToNextPage: function goToNextPage() {\n      this.previous.push(this.pageOffset);\n      this.pageOffset = this.next;\n      this.next = null;\n      this.loadData();\n    },\n    tableAction: function tableAction(ev) {\n      var data = ev; // reset back to the first tab\n\n      this.$store.dispatch('updateSelectedTab', this.tabs[0].hash); // set the active table row\n\n      this.$store.dispatch('updateSelectedTableRow', data.name); // load the data into the tabs\n\n      this.getEntity(data);\n    },\n    loadData: function loadData() {\n      var _this = this;\n\n      this.isLoading = true;\n      this.isEmpty = false;\n      var mesh = this.$route.params.mesh;\n      var params = {\n        size: this.pageSize,\n        offset: this.pageOffset\n      };\n      var endpoint = mesh === 'all' ? this.$api.getAllDataplanes(params) : this.$api.getAllDataplanesFromMesh(mesh);\n\n      var getDataplanes = function getDataplanes() {\n        return endpoint.then(function (response) {\n          if (response.items.length > 0) {\n            // check to see if the `next` url is present\n            if (response.next) {\n              _this.next = getOffset(response.next);\n              _this.hasNext = true;\n            } else {\n              _this.hasNext = false;\n            }\n\n            var items = _this.sortEntities(response.items);\n\n            var final = []; // set the first item as the default for initial load\n\n            _this.firstEntity = items[0].name; // load the YAML entity for the first item on page load\n\n            _this.getEntity(items[0]); // set the selected table row for the first item on page load\n\n\n            _this.$store.dispatch('updateSelectedTableRow', _this.firstEntity);\n\n            items.forEach(function (item) {\n              _this.$api.getDataplaneOverviewsFromMesh(item.mesh, item.name).then(function (response) {\n                var placeholder = 'n/a';\n                var lastConnected;\n                var lastUpdated;\n                var tags = placeholder;\n                var totalUpdates = [];\n                var status = 'Offline';\n                var connectTimes = [];\n                var updateTimes = [];\n                /**\n                 * Iterate through the networking inbound or gateway data\n                 */\n\n                var inbound = response.dataplane.networking.inbound;\n                var gateway = response.dataplane.networking.gateway;\n\n                if (inbound || gateway) {\n                  if (inbound) {\n                    /** inbound */\n                    for (var i = 0; i < inbound.length; i++) {\n                      var rawTags = inbound[i].tags;\n                      var _final = [];\n                      var tagKeys = Object.keys(rawTags);\n                      var tagVals = Object.values(rawTags);\n\n                      for (var x = 0; x < tagKeys.length; x++) {\n                        _final.push({\n                          label: tagKeys[x],\n                          value: tagVals[x]\n                        });\n                      }\n\n                      tags = _final;\n                    }\n                  } else if (gateway) {\n                    /** gateway */\n                    var _items = gateway.tags;\n\n                    for (var _i = 0; _i < Object.keys(_items).length; _i++) {\n                      var _final2 = [];\n\n                      var _tagKeys = Object.keys(_items);\n\n                      var _tagVals = Object.values(_items);\n\n                      for (var _x = 0; _x < _tagKeys.length; _x++) {\n                        _final2.push({\n                          label: _tagKeys[_x],\n                          value: _tagVals[_x]\n                        });\n                      }\n\n                      tags = _final2;\n                    }\n                  }\n                } else {\n                  tags = 'none';\n                }\n                /**\n                 * Iterate through the subscriptions\n                 */\n\n\n                if (response.dataplaneInsight.subscriptions && response.dataplaneInsight.subscriptions.length) {\n                  response.dataplaneInsight.subscriptions.forEach(function (item) {\n                    var responsesSent = item.status.total.responsesSent || 0;\n                    var connectTime = item.connectTime || placeholder;\n                    var lastUpdateTime = item.status.lastUpdateTime || placeholder;\n                    var disconnectTime = item.disconnectTime || null;\n                    totalUpdates.push(responsesSent);\n                    connectTimes.push(connectTime);\n                    updateTimes.push(lastUpdateTime);\n\n                    if (connectTime && connectTime.length && !disconnectTime) {\n                      status = 'Online';\n                    } else {\n                      status = 'Offline';\n                    }\n                  }); // get the sum of total updates (with some precautions)\n\n                  totalUpdates = totalUpdates.reduce(function (a, b) {\n                    return a + b;\n                  }); // select the most recent LAST CONNECTED timestamp\n\n                  var selectedTime = connectTimes.reduce(function (a, b) {\n                    if (a && b) {\n                      return a.MeasureDate > b.MeasureDate ? a : b;\n                    }\n\n                    return null;\n                  }); // select the most recent LAST UPDATED timestamnp\n\n                  var selectedUpdateTime = updateTimes.reduce(function (a, b) {\n                    if (a && b) {\n                      return a.MeasureDate > b.MeasureDate ? a : b;\n                    }\n\n                    return null;\n                  }); // format each reduced value as a date to compare against\n\n                  var selectedTimeAsDate = new Date(selectedTime);\n                  var selectedUpdateTimeAsDate = new Date(selectedUpdateTime);\n                  /**\n                   * @todo refactor this to use a function instead\n                   */\n                  // formatted time for LAST CONNECTED (if there is a value present)\n\n                  if (selectedTime && !isNaN(selectedTimeAsDate)) {\n                    lastConnected = humanReadableDate(selectedTimeAsDate);\n                  } else {\n                    lastConnected = 'never';\n                  } // formatted time for LAST UPDATED (if there is a value present)\n\n\n                  if (selectedUpdateTime && !isNaN(selectedUpdateTimeAsDate)) {\n                    lastUpdated = humanReadableDate(selectedUpdateTimeAsDate);\n                  } else {\n                    lastUpdated = 'never';\n                  }\n                } else {\n                  // if there are no subscriptions, set them all to a fallback\n                  lastConnected = 'never';\n                  lastUpdated = 'never';\n                  totalUpdates = 0;\n                } // assemble the table data\n\n\n                final.push({\n                  name: response.name,\n                  mesh: response.mesh,\n                  tags: tags,\n                  status: status,\n                  lastConnected: lastConnected,\n                  lastUpdated: lastUpdated,\n                  totalUpdates: totalUpdates,\n                  type: 'dataplane'\n                });\n\n                _this.sortEntities(final);\n              }).catch(function (error) {\n                console.error(error);\n              });\n            });\n            _this.tableData.data = final;\n            _this.tableDataIsEmpty = false;\n          } else {\n            _this.tableData.data = [];\n            _this.tableDataIsEmpty = true;\n\n            _this.getEntity(null);\n          }\n        }).catch(function (error) {\n          _this.hasError = true;\n          console.error(error);\n        }).finally(function () {\n          setTimeout(function () {\n            _this.isLoading = false;\n          }, process.env.VUE_APP_DATA_TIMEOUT);\n        });\n      };\n\n      getDataplanes();\n    },\n    getEntity: function getEntity(entity) {\n      var _this2 = this;\n\n      this.entityIsLoading = true;\n      this.entityIsEmpty = false;\n      var mesh = this.$route.params.mesh;\n\n      if (entity && entity !== null) {\n        var entityMesh = mesh === 'all' ? entity.mesh : mesh;\n        return this.$api.getDataplaneFromMesh(entityMesh, entity.name).then(function (response) {\n          if (response) {\n            var selected = ['type', 'name', 'mesh', 'tags']; // determine between inbound and gateway modes\n            // and then get the tags from which condition applies.\n\n            var tagSrc = response.networking.inbound && response.networking.inbound.length > 0 ? response.networking.inbound[0].tags : response.networking.gateway.tags;\n\n            var newEntity = _objectSpread(_objectSpread({}, getSome(response, selected)), {\n              tags: tagSrc\n            });\n\n            _this2.entity = newEntity;\n            _this2.rawEntity = response;\n          } else {\n            _this2.entity = null;\n            _this2.entityIsEmpty = true;\n          }\n        }).catch(function (error) {\n          _this2.entityHasError = true;\n          console.error(error);\n        }).finally(function () {\n          setTimeout(function () {\n            _this2.entityIsLoading = false;\n          }, process.env.VUE_APP_DATA_TIMEOUT);\n        });\n      } else {\n        setTimeout(function () {\n          _this2.entityIsEmpty = true;\n          _this2.entityIsLoading = false;\n        }, process.env.VUE_APP_DATA_TIMEOUT);\n      }\n    }\n  }\n};",{"version":3,"sources":["Dataplanes.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div class=\"dataplanes\">\n    <FrameSkeleton>\n      <DataOverview\n        :page-size=\"pageSize\"\n        :has-error=\"hasError\"\n        :is-loading=\"isLoading\"\n        :is-empty=\"isEmpty\"\n        :empty-state=\"empty_state\"\n        :display-data-table=\"true\"\n        :table-data=\"tableData\"\n        :table-data-is-empty=\"tableDataIsEmpty\"\n        table-data-function-text=\"View\"\n        table-data-row=\"name\"\n        @tableAction=\"tableAction\"\n        @reloadData=\"loadData\"\n      >\n        <template slot=\"additionalControls\">\n          <KButton\n            class=\"add-dp-button\"\n            appearance=\"primary\"\n            size=\"small\"\n            :to=\"dataplaneWizardRoute\"\n          >\n            Create Dataplane\n          </KButton>\n        </template>\n        <template slot=\"pagination\">\n          <Pagination\n            :has-previous=\"previous.length > 0\"\n            :has-next=\"hasNext\"\n            @next=\"goToNextPage\"\n            @previous=\"goToPreviousPage\"\n          />\n        </template>\n      </DataOverview>\n      <Tabs\n        :has-error=\"hasError\"\n        :is-loading=\"isLoading\"\n        :is-empty=\"isEmpty\"\n        :tabs=\"tabs\"\n        :tab-group-title=\"tabGroupTitle\"\n        initial-tab-override=\"overview\"\n      >\n        <template slot=\"overview\">\n          <LabelList\n            :has-error=\"entityHasError\"\n            :is-loading=\"entityIsLoading\"\n            :is-empty=\"entityIsEmpty\"\n            :items=\"entity\"\n          />\n        </template>\n        <template slot=\"yaml\">\n          <YamlView\n            :title=\"entityOverviewTitle\"\n            :has-error=\"entityHasError\"\n            :is-loading=\"entityIsLoading\"\n            :is-empty=\"entityIsEmpty\"\n            :content=\"rawEntity\"\n          />\n        </template>\n      </Tabs>\n    </FrameSkeleton>\n  </div>\n</template>\n\n<script>\nimport { mapGetters } from 'vuex'\nimport { getSome, humanReadableDate, getOffset } from '@/helpers'\nimport sortEntities from '@/mixins/EntitySorter'\nimport FrameSkeleton from '@/components/Skeletons/FrameSkeleton'\nimport Pagination from '@/components/Pagination'\nimport DataOverview from '@/components/Skeletons/DataOverview'\nimport Tabs from '@/components/Utils/Tabs'\nimport YamlView from '@/components/Skeletons/YamlView'\nimport LabelList from '@/components/Utils/LabelList'\n\nexport default {\n  name: 'Dataplanes',\n  metaInfo: {\n    title: 'Dataplanes'\n  },\n  components: {\n    FrameSkeleton,\n    Pagination,\n    DataOverview,\n    Tabs,\n    YamlView,\n    LabelList\n  },\n  mixins: [\n    sortEntities\n  ],\n  data () {\n    return {\n      isLoading: true,\n      isEmpty: false,\n      hasError: false,\n      entityIsLoading: true,\n      entityIsEmpty: false,\n      entityHasError: false,\n      tableDataIsEmpty: false,\n      empty_state: {\n        title: 'No Data',\n        message: 'There are no Dataplanes present.'\n      },\n      tableData: {\n        headers: [\n          { key: 'actions', hideLabel: true },\n          { label: 'Status', key: 'status' },\n          { label: 'Name', key: 'name' },\n          { label: 'Mesh', key: 'mesh' },\n          { label: 'Tags', key: 'tags' },\n          { label: 'Last Connected', key: 'lastConnected' },\n          { label: 'Last Updated', key: 'lastUpdated' },\n          { label: 'Total Updates', key: 'totalUpdates' }\n        ],\n        data: []\n      },\n      tabs: [\n        {\n          hash: '#overview',\n          title: 'Overview'\n        },\n        {\n          hash: '#yaml',\n          title: 'YAML'\n        }\n      ],\n      entity: null,\n      rawEntity: null,\n      firstEntity: null,\n      pageSize: this.$pageSize,\n      pageOffset: null,\n      next: null,\n      hasNext: false,\n      previous: []\n    }\n  },\n  computed: {\n    ...mapGetters({\n      environment: 'getEnvironment'\n    }),\n    tabGroupTitle () {\n      const entity = this.entity\n\n      if (entity) {\n        return `Dataplane: ${entity.name}`\n      } else {\n        return null\n      }\n    },\n    entityOverviewTitle () {\n      const entity = this.entity\n\n      if (entity) {\n        return `Entity Overview for ${entity.name}`\n      } else {\n        return null\n      }\n    },\n    dataplaneWizardRoute () {\n      // we change the route to the Dataplane\n      // wizard based on environment.\n      if (this.environment === 'universal') {\n        return { name: 'universal-dataplane' }\n      } else {\n        return { name: 'kubernetes-dataplane' }\n      }\n    }\n  },\n  watch: {\n    '$route' (to, from) {\n      this.loadData()\n    }\n  },\n  beforeMount () {\n    this.loadData()\n  },\n  methods: {\n    init () {\n      this.loadData()\n    },\n    goToPreviousPage () {\n      this.pageOffset = this.previous.pop()\n      this.next = null\n\n      this.loadData()\n    },\n    goToNextPage () {\n      this.previous.push(this.pageOffset)\n      this.pageOffset = this.next\n      this.next = null\n\n      this.loadData()\n    },\n    tableAction (ev) {\n      const data = ev\n\n      // reset back to the first tab\n      this.$store.dispatch('updateSelectedTab', this.tabs[0].hash)\n\n      // set the active table row\n      this.$store.dispatch('updateSelectedTableRow', data.name)\n\n      // load the data into the tabs\n      this.getEntity(data)\n    },\n    loadData () {\n      this.isLoading = true\n      this.isEmpty = false\n\n      const mesh = this.$route.params.mesh\n\n      const params = {\n        size: this.pageSize,\n        offset: this.pageOffset\n      }\n\n      const endpoint = (mesh === 'all')\n        ? this.$api.getAllDataplanes(params)\n        : this.$api.getAllDataplanesFromMesh(mesh)\n\n      const getDataplanes = () => {\n        return endpoint\n          .then(response => {\n            if (response.items.length > 0) {\n              // check to see if the `next` url is present\n              if (response.next) {\n                this.next = getOffset(response.next)\n                this.hasNext = true\n              } else {\n                this.hasNext = false\n              }\n\n              const items = this.sortEntities(response.items)\n              const final = []\n\n              // set the first item as the default for initial load\n              this.firstEntity = items[0].name\n\n              // load the YAML entity for the first item on page load\n              this.getEntity(items[0])\n\n              // set the selected table row for the first item on page load\n              this.$store.dispatch('updateSelectedTableRow', this.firstEntity)\n\n              items.forEach(item => {\n                this.$api.getDataplaneOverviewsFromMesh(item.mesh, item.name)\n                  .then(response => {\n                    const placeholder = 'n/a'\n\n                    let lastConnected\n                    let lastUpdated\n                    let tags = placeholder\n                    let totalUpdates = []\n                    let status = 'Offline'\n                    const connectTimes = []\n                    const updateTimes = []\n\n                    /**\n                     * Iterate through the networking inbound or gateway data\n                     */\n                    const inbound = response.dataplane.networking.inbound\n                    const gateway = response.dataplane.networking.gateway\n\n                    if (inbound || gateway) {\n                      if (inbound) {\n                        /** inbound */\n                        for (let i = 0; i < inbound.length; i++) {\n                          const rawTags = inbound[i].tags\n\n                          const final = []\n                          const tagKeys = Object.keys(rawTags)\n                          const tagVals = Object.values(rawTags)\n\n                          for (let x = 0; x < tagKeys.length; x++) {\n                            final.push({\n                              label: tagKeys[x],\n                              value: tagVals[x]\n                            })\n                          }\n\n                          tags = final\n                        }\n                      } else if (gateway) {\n                        /** gateway */\n                        const items = gateway.tags\n\n                        for (let i = 0; i < Object.keys(items).length; i++) {\n                          const final = []\n                          const tagKeys = Object.keys(items)\n                          const tagVals = Object.values(items)\n\n                          for (let x = 0; x < tagKeys.length; x++) {\n                            final.push({\n                              label: tagKeys[x],\n                              value: tagVals[x]\n                            })\n                          }\n\n                          tags = final\n                        }\n                      }\n                    } else {\n                      tags = 'none'\n                    }\n\n                    /**\n                     * Iterate through the subscriptions\n                     */\n                    if (response.dataplaneInsight.subscriptions && response.dataplaneInsight.subscriptions.length) {\n                      response.dataplaneInsight.subscriptions.forEach(item => {\n                        const responsesSent = item.status.total.responsesSent || 0\n                        const connectTime = item.connectTime || placeholder\n                        const lastUpdateTime = item.status.lastUpdateTime || placeholder\n                        const disconnectTime = item.disconnectTime || null\n\n                        totalUpdates.push(responsesSent)\n                        connectTimes.push(connectTime)\n                        updateTimes.push(lastUpdateTime)\n\n                        if (connectTime && connectTime.length && !disconnectTime) {\n                          status = 'Online'\n                        } else {\n                          status = 'Offline'\n                        }\n                      })\n\n                      // get the sum of total updates (with some precautions)\n                      totalUpdates = totalUpdates.reduce((a, b) => a + b)\n\n                      // select the most recent LAST CONNECTED timestamp\n                      const selectedTime = connectTimes.reduce((a, b) => {\n                        if (a && b) {\n                          return a.MeasureDate > b.MeasureDate ? a : b\n                        }\n\n                        return null\n                      })\n\n                      // select the most recent LAST UPDATED timestamnp\n                      const selectedUpdateTime = updateTimes.reduce((a, b) => {\n                        if (a && b) {\n                          return a.MeasureDate > b.MeasureDate ? a : b\n                        }\n\n                        return null\n                      })\n\n                      // format each reduced value as a date to compare against\n                      const selectedTimeAsDate = new Date(selectedTime)\n                      const selectedUpdateTimeAsDate = new Date(selectedUpdateTime)\n\n                      /**\n                       * @todo refactor this to use a function instead\n                       */\n\n                      // formatted time for LAST CONNECTED (if there is a value present)\n                      if (selectedTime && !isNaN(selectedTimeAsDate)) {\n                        lastConnected = humanReadableDate(selectedTimeAsDate)\n                      } else {\n                        lastConnected = 'never'\n                      }\n\n                      // formatted time for LAST UPDATED (if there is a value present)\n                      if (selectedUpdateTime && !isNaN(selectedUpdateTimeAsDate)) {\n                        lastUpdated = humanReadableDate(selectedUpdateTimeAsDate)\n                      } else {\n                        lastUpdated = 'never'\n                      }\n                    } else {\n                      // if there are no subscriptions, set them all to a fallback\n                      lastConnected = 'never'\n                      lastUpdated = 'never'\n                      totalUpdates = 0\n                    }\n\n                    // assemble the table data\n                    final.push({\n                      name: response.name,\n                      mesh: response.mesh,\n                      tags: tags,\n                      status: status,\n                      lastConnected: lastConnected,\n                      lastUpdated: lastUpdated,\n                      totalUpdates: totalUpdates,\n                      type: 'dataplane'\n                    })\n\n                    this.sortEntities(final)\n                  })\n                  .catch(error => {\n                    console.error(error)\n                  })\n              })\n\n              this.tableData.data = final\n              this.tableDataIsEmpty = false\n            } else {\n              this.tableData.data = []\n              this.tableDataIsEmpty = true\n\n              this.getEntity(null)\n            }\n          })\n          .catch(error => {\n            this.hasError = true\n\n            console.error(error)\n          })\n          .finally(() => {\n            setTimeout(() => {\n              this.isLoading = false\n            }, process.env.VUE_APP_DATA_TIMEOUT)\n          })\n      }\n\n      getDataplanes()\n    },\n    getEntity (entity) {\n      this.entityIsLoading = true\n      this.entityIsEmpty = false\n\n      const mesh = this.$route.params.mesh\n\n      if (entity && entity !== null) {\n        const entityMesh = (mesh === 'all')\n          ? entity.mesh\n          : mesh\n\n        return this.$api.getDataplaneFromMesh(entityMesh, entity.name)\n          .then(response => {\n            if (response) {\n              const selected = ['type', 'name', 'mesh', 'tags']\n\n              // determine between inbound and gateway modes\n              // and then get the tags from which condition applies.\n              const tagSrc = (response.networking.inbound && response.networking.inbound.length > 0)\n                ? response.networking.inbound[0].tags\n                : response.networking.gateway.tags\n\n              const newEntity = {\n                ...getSome(response, selected),\n                ...{\n                  tags: tagSrc\n                }\n              }\n\n              this.entity = newEntity\n\n              this.rawEntity = response\n            } else {\n              this.entity = null\n              this.entityIsEmpty = true\n            }\n          })\n          .catch(error => {\n            this.entityHasError = true\n            console.error(error)\n          })\n          .finally(() => {\n            setTimeout(() => {\n              this.entityIsLoading = false\n            }, process.env.VUE_APP_DATA_TIMEOUT)\n          })\n      } else {\n        setTimeout(() => {\n          this.entityIsEmpty = true\n          this.entityIsLoading = false\n        }, process.env.VUE_APP_DATA_TIMEOUT)\n      }\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.add-dp-button {\n  background-color: var(--logo-green) !important;\n}\n</style>\n"],"sourceRoot":"src/views/Entities"}]}